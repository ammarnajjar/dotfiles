# man bash | grep -A1 '\-f file$'
#        -f file
#               True if file exists and is a regular file.
#        -r file
#               True if file exists and is readable.
import () {
    [[ -r "$1" ]] && source "$1"
}

# GIT_PROMPT_ONLY_IN_REPO=1
GIT_PROMPT_FETCH_REMOTE_STATUS=0   # uncomment to avoid fetching remote status
GIT_PROMPT_IGNORE_SUBMODULES=1 # uncomment to avoid searching for changed files in submodules
GIT_PROMPT_SHOW_UNTRACKED_FILES=normal # can be no, normal or all; determines counting of untracked files
GIT_PROMPT_THEME=Minimal

shopt -s histappend

import $dotfiles_dir/shell/common.sh

import $HOME/.fzf.bash
import $ASDF_DIR/asdf.sh
import $ASDF_DIR/completions/asdf.bash

import $dotfiles_dir/shell/bash/bash-sensible/sensible.bash
import /etc/bash_completion
import /usr/local/git/contrib/completion/git-completion.bash
import /usr/share/doc/git/contrib/completion/git-completion.bash

# custom prompt
RED='\033[0;31m'
YELLOW='\033[0;33m'
LIGHT_GREEN='\033[0;32m'
LIGHT_GRAY='\033[0;37m'
NORMAL='\033[0m'

function prompt_right() {
    echo -e "${LIGHT_GRAY}\\\t${NORMAL}"
}

function prompt_left() {
    GIT_BRANCH=""
    BRANCH=$(git branch 2>/dev/null | grep '^*' | sed s/..//)
    if [ ! -z "$BRANCH" ]; then  GIT_BRANCH=" [${LIGHT_GREEN}${BRANCH}${NORMAL}]"; fi
    echo -e "${YELLOW}\w${NORMAL}${GIT_BRANCH}"
}

function prompt_command() {
    compensate=4
    PS1=$(printf "%*s\r%s\n\$ " "$(($(tput cols)+${compensate}))" "$(prompt_right)" "$(prompt_left)")
}
PROMPT_COMMAND=prompt_command

import $HOME/.local_bashrc

# asdf direnv setup --shell /usr/local/bin/bash --version latest
import "${XDG_CONFIG_HOME:-$HOME/.config}/asdf-direnv/bashrc"

if [ -n "$(type -t kubectl)" ] && [ "$(type -t kubectl)" = function ]; then
    source <(kubectl completion bash)
fi

# vim: set ft=sh ts=4 sw=4 et ai :
