# man bash | grep -A1 '\-f file$'
#        -f file
#               True if file exists and is a regular file.
#        -r file
#               True if file exists and is readable.
import () {
    [[ -r "$1" ]] && source "$1"
}

shopt -s histappend

import $dotfiles_dir/shell/common.sh

import $HOME/.fzf.bash
import $ASDF_DIR/asdf.sh
import $ASDF_DIR/completions/asdf.bash

import $dotfiles_dir/shell/bash/bash-sensible/sensible.bash
import /etc/bash_completion
import /usr/local/git/contrib/completion/git-completion.bash
import /usr/share/doc/git/contrib/completion/git-completion.bash

# custom prompt
RED='\033[0;31m'
YELLOW='\033[0;33m'
LIGHT_GREEN='\033[0;32m'
LIGHT_GRAY='\033[0;37m'
LIGHT_PURPLE='\033[0;35m'
NORMAL='\033[0m'


COMPENSATE=4

function prompt_right() {
    echo -e "${LIGHT_GRAY}\\\t${NORMAL}"
}

function prompt_left() {
    VENV=""
    if [ ! -z "$VIRTUAL_ENV" ]; then 
        VENV="(${LIGHT_PURPLE}`basename \"$VIRTUAL_ENV\"`${NORMAL}) "
    fi
    GIT_BRANCH=""
    BRANCH=$(git branch 2>/dev/null | grep '^*' | sed s/..//)
    if [ ! -z "$BRANCH" ]; then  GIT_BRANCH=" [${LIGHT_GREEN}${BRANCH}${NORMAL}]"; fi
    echo -e "${VENV}${YELLOW}\w${NORMAL}${GIT_BRANCH}"
}

function prompt_command() {
    PS1=$(printf "%*s\r%s\n\$ " "$(($(tput cols)+${COMPENSATE}))" "$(prompt_right)" "$(prompt_left)")
}
PROMPT_COMMAND=prompt_command

import $HOME/.local_bashrc

# asdf direnv setup --shell /usr/local/bin/bash --version latest
import "${XDG_CONFIG_HOME:-$HOME/.config}/asdf-direnv/bashrc"

if [ -n "$(type -t kubectl)" ] && [ "$(type -t kubectl)" = function ]; then
    source <(kubectl completion bash)
fi

# vim: set ft=sh ts=4 sw=4 et ai :
